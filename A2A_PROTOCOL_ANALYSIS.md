# A2A Protocol & Multi-Agent Implementation Analysis

## Executive Summary

After thoroughly analyzing the **Agent2Agent (A2A) Protocol** and the **Airbnb Planner Multi-Agent** sample implementation, I now have a comprehensive understanding of how to properly implement a multi-agent system using Google's Agent Development Kit (ADK) with the A2A protocol.

---

## 1. What is A2A Protocol?

### Core Purpose

A2A is an **open protocol** that enables **communication and interoperability between opaque AI agents**. It solves the critical problem of allowing agents built on different frameworks, by different companies, running on separate servers to communicate and collaborate effectively.

### Key Principles

1. **Agents as Agents, Not Tools**: Unlike MCP (Model Context Protocol) which wraps agents as tools, A2A allows agents to communicate in their native modality
2. **Opaque Execution**: Agents collaborate without exposing internal state, memory, or proprietary tools
3. **Standardized Communication**: Uses JSON-RPC 2.0 over HTTP(S)
4. **Enterprise-Ready**: Built-in support for authentication, authorization, security, and observability
5. **Async-First**: Designed for long-running tasks and human-in-the-loop scenarios

### A2A vs MCP

- **MCP**: Connects models to data and external resources (tools are stateless, perform specific functions)
- **A2A**: Enables agents to collaborate as agents, supporting complex multi-turn interactions, negotiation, and delegation

---

## 2. Core A2A Concepts

### 2.1 Agent Card

A JSON metadata document that serves as a "digital business card" for an agent:

- **Identity**: Name, description, version
- **Capabilities**: Streaming, push notifications
- **Skills**: What the agent can do (with examples)
- **Endpoint**: Service URL
- **Authentication**: Security requirements
- **Supported Content Types**: Text, files, structured data

### 2.2 Task

The fundamental unit of work in A2A:

- **Unique ID**: Each task has a unique identifier
- **Lifecycle**: Tasks progress through states (submitted → working → completed/input_required/auth-required)
- **Context**: Optional grouping of related tasks
- **Stateful**: Tasks maintain state across interactions

### 2.3 Message

A single turn of communication:

- **Role**: "user" or "agent"
- **Parts**: One or more content containers (TextPart, FilePart, DataPart)
- **Message ID**: Unique identifier
- **Task ID**: Links message to a task

### 2.4 Artifact

Tangible outputs generated by an agent:

- **Artifact ID**: Unique identifier
- **Name**: Human-readable name
- **Parts**: Content containers
- **Streamable**: Can be sent incrementally

### 2.5 Interaction Mechanisms

1. **Request/Response**: Synchronous communication with polling for long-running tasks
2. **Streaming (SSE)**: Real-time incremental updates via Server-Sent Events
3. **Push Notifications**: Asynchronous updates via webhooks for very long tasks

---

## 3. Airbnb Planner Multi-Agent Architecture

### 3.1 System Overview

The sample demonstrates a **host agent (orchestrator)** coordinating tasks between **remote agents** (Airbnb, Weather) that interact with MCP servers.

```
User → Host Agent (Orchestrator) → Remote Agents (Airbnb, Weather) → MCP Servers
```

### 3.2 Component Breakdown

#### **Host Agent (Routing Agent)**

- **Role**: Orchestrator that delegates tasks to specialized agents
- **Key Features**:
  - Discovers remote agents via Agent Cards
  - Routes user queries to appropriate specialist agents
  - Maintains session state and context
  - Handles multi-agent coordination
  - Uses ADK's `Agent` class with tools

**Key Implementation Details**:

```python
class RoutingAgent:
    def __init__(self, task_callback=None):
        self.remote_agent_connections: dict[str, RemoteAgentConnections] = {}
        self.cards: dict[str, AgentCard] = {}

    async def _async_init_components(self, remote_agent_addresses: list[str]):
        # Fetch Agent Cards from remote agents
        async with httpx.AsyncClient(timeout=30) as client:
            for address in remote_agent_addresses:
                card_resolver = A2ACardResolver(client, address)
                card = await card_resolver.get_agent_card()
                remote_connection = RemoteAgentConnections(
                    agent_card=card, agent_url=address
                )
                self.remote_agent_connections[card.name] = remote_connection

    def create_agent(self) -> Agent:
        return Agent(
            model='gemini-2.5-flash-lite',
            name='Routing_agent',
            instruction=self.root_instruction,
            before_model_callback=self.before_model_callback,
            tools=[self.send_message],  # Tool to send messages to remote agents
        )

    async def send_message(self, agent_name: str, task: str, tool_context: ToolContext):
        # Send task to remote agent using A2A protocol
        client = self.remote_agent_connections[agent_name]
        message_request = SendMessageRequest(...)
        send_response = await client.send_message(message_request)
        return send_response.root.result
```

**Key Insights**:

- Uses ADK's `Agent` class with custom tools
- Tools are async functions that can call remote agents
- Session management via `before_model_callback`
- Dynamic instruction generation based on available agents

#### **Remote Agents (Airbnb, Weather)**

- **Role**: Specialized agents that handle specific domains
- **Key Features**:
  - Expose A2A-compliant HTTP endpoints
  - Publish Agent Cards
  - Use LangGraph for agent logic (not ADK in this case)
  - Integrate with MCP servers for tool access

**Key Implementation Details**:

```python
class AirbnbAgent:
    SYSTEM_INSTRUCTION = """You are a specialized assistant for Airbnb..."""

    def __init__(self, mcp_tools: list[Any]):
        self.model = ChatGoogleGenerativeAI(model=model)
        self.mcp_tools = mcp_tools

    async def ainvoke(self, query: str, session_id: str) -> dict[str, Any]:
        airbnb_agent_runnable = create_react_agent(
            self.model,
            tools=self.mcp_tools,
            checkpointer=memory,
            prompt=self.SYSTEM_INSTRUCTION,
            response_format=(self.RESPONSE_FORMAT_INSTRUCTION, ResponseFormat),
        )
        config: RunnableConfig = {'configurable': {'thread_id': session_id}}
        await airbnb_agent_runnable.ainvoke({'messages': [('user', query)]}, config)
        return self._get_agent_response_from_state(config, airbnb_agent_runnable)
```

#### **Agent Executor (A2A Wrapper)**

- **Role**: Wraps the agent logic to be A2A-compliant
- **Key Features**:
  - Implements `AgentExecutor` interface from `a2a.server`
  - Translates A2A requests to agent invocations
  - Manages task lifecycle and events
  - Handles streaming responses

**Key Implementation Details**:

```python
class AirbnbAgentExecutor(AgentExecutor):
    def __init__(self, mcp_tools: list[Any]):
        super().__init__()
        self.agent = AirbnbAgent(mcp_tools=mcp_tools)

    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        query = context.get_user_input()
        task = context.current_task

        if not task:
            task = new_task(context.message)
            await event_queue.enqueue_event(task)

        # Stream results from agent
        async for event in self.agent.stream(query, task.context_id):
            if event['is_task_complete']:
                await event_queue.enqueue_event(
                    TaskArtifactUpdateEvent(
                        artifact=new_text_artifact(text=event['content']),
                        ...
                    )
                )
                await event_queue.enqueue_event(
                    TaskStatusUpdateEvent(status=TaskStatus(state=TaskState.completed), ...)
                )
            elif event['require_user_input']:
                await event_queue.enqueue_event(
                    TaskStatusUpdateEvent(
                        status=TaskStatus(state=TaskState.input_required, ...),
                        ...
                    )
                )
```

#### **A2A Server Setup**

- **Role**: Exposes the agent as an A2A-compliant HTTP server
- **Key Features**:
  - Uses `A2AStarletteApplication` from `a2a.server`
  - Publishes Agent Card
  - Handles HTTP requests and routing
  - Manages MCP tool lifecycle

**Key Implementation Details**:

```python
async def app_lifespan(context: dict[str, Any]):
    # Initialize MCP client and tools
    mcp_client_instance = MultiServerMCPClient(SERVER_CONFIGS)
    mcp_tools = await mcp_client_instance.get_tools()
    context['mcp_tools'] = mcp_tools
    yield
    await mcp_client_instance.__aexit__(None, None, None)

def main():
    async def run_server_async():
        async with app_lifespan(app_context):
            airbnb_agent_executor = AirbnbAgentExecutor(
                mcp_tools=app_context.get('mcp_tools', [])
            )
            request_handler = DefaultRequestHandler(
                agent_executor=airbnb_agent_executor,
                task_store=InMemoryTaskStore(),
            )
            a2a_server = A2AStarletteApplication(
                agent_card=get_agent_card(host, port),
                http_handler=request_handler,
            )
            asgi_app = a2a_server.build()
            config = uvicorn.Config(app=asgi_app, host=host, port=port, ...)
            uvicorn_server = uvicorn.Server(config)
            await uvicorn_server.serve()

    asyncio.run(run_server_async())

def get_agent_card(host: str, port: int):
    return AgentCard(
        name='Airbnb Agent',
        description='Helps with searching accommodation',
        url=f'http://{host}:{port}',
        version='1.0.0',
        capabilities=AgentCapabilities(streaming=True, push_notifications=True),
        skills=[AgentSkill(
            id='airbnb_search',
            name='Search airbnb accommodation',
            description='Helps with accommodation search using airbnb',
            examples=['Please find a room in LA, CA, April 15, 2025...']
        )],
    )
```

---

## 4. Key Architectural Patterns

### 4.1 Agent Discovery Pattern

1. Host agent fetches Agent Cards from remote agent URLs
2. Parses capabilities, skills, and authentication requirements
3. Stores connections for routing decisions

### 4.2 Task Delegation Pattern

1. User sends query to host agent
2. Host agent analyzes query and determines which specialist agent(s) to use
3. Host agent creates A2A message and sends to remote agent
4. Remote agent processes task and returns results
5. Host agent aggregates results and responds to user

### 4.3 Session Management Pattern

1. Each task has a unique `task_id` and `context_id`
2. Context groups related tasks together
3. Session state is maintained per agent (not shared)
4. Multi-turn conversations use the same `context_id`

### 4.4 Streaming Pattern

1. Agent executor yields events as work progresses
2. Events include status updates, artifacts, and messages
3. Client receives real-time updates via SSE
4. Final event marks task as complete

---

## 5. How This Applies to Our Legal AI App

### 5.1 Current Architecture Issues

Our current implementation has several issues:

1. **No A2A Protocol**: Agents are not exposed as A2A servers
2. **Monolithic Orchestrator**: All logic is in `app.py` instead of distributed agents
3. **No Agent Cards**: No standardized way to discover agent capabilities
4. **No Task Management**: No proper task lifecycle or state management
5. **No Streaming**: Limited real-time updates to frontend

### 5.2 Recommended Architecture

```
Frontend (React/Next.js)
    ↓
Host Agent (Orchestrator) - ADK Agent with A2A Client
    ↓
├── Client Communication Agent (A2A Server)
│   └── Email drafting, message composition
├── Legal Researcher Agent (A2A Server)
│   └── Case law search, precedent research
├── Records Wrangler Agent (A2A Server)
│   └── Document retrieval, record requests
├── Voice Scheduler Agent (A2A Server)
│   └── Appointment scheduling, calendar management
└── Evidence Sorter Agent (A2A Server)
    └── Document classification, evidence organization
```

### 5.3 Implementation Steps

#### **Step 1: Create Specialized A2A Agents**

Each specialist agent should:

- Implement `AgentExecutor` interface
- Expose A2A-compliant HTTP endpoint
- Publish Agent Card with skills
- Use ADK or LangGraph for agent logic
- Integrate with existing backend services (Snowflake, DigitalOcean Spaces, etc.)

Example for Client Communication Agent:

```python
class ClientCommunicationAgent:
    SYSTEM_INSTRUCTION = """You are a professional legal assistant..."""

    async def ainvoke(self, query: str, session_id: str) -> dict[str, Any]:
        # Use Gemini to draft email
        # Access case context from Snowflake
        # Return structured response
        pass

class ClientCommunicationExecutor(AgentExecutor):
    async def execute(self, context: RequestContext, event_queue: EventQueue):
        # Wrap agent logic in A2A protocol
        pass

# Server setup
def main():
    executor = ClientCommunicationExecutor()
    handler = DefaultRequestHandler(executor, InMemoryTaskStore())
    server = A2AStarletteApplication(
        agent_card=AgentCard(
            name='Client Communication Agent',
            skills=[AgentSkill(
                id='draft_email',
                name='Draft Client Email',
                description='Draft professional emails to clients',
            )],
        ),
        http_handler=handler,
    )
    # Run server on port 10001
```

#### **Step 2: Create Host Agent (Orchestrator)**

The orchestrator should:

- Use ADK's `Agent` class
- Discover remote agents via Agent Cards
- Route tasks based on user intent
- Maintain session state
- Aggregate results from multiple agents

Example:

```python
class LegalOrchestrator:
    def __init__(self):
        self.remote_agents = {}

    async def init_agents(self):
        # Discover agents
        agent_urls = [
            'http://localhost:10001',  # Client Communication
            'http://localhost:10002',  # Legal Researcher
            'http://localhost:10003',  # Records Wrangler
            'http://localhost:10004',  # Voice Scheduler
            'http://localhost:10005',  # Evidence Sorter
        ]
        for url in agent_urls:
            card = await A2ACardResolver(client, url).get_agent_card()
            self.remote_agents[card.name] = RemoteAgentConnections(card, url)

    def create_agent(self) -> Agent:
        return Agent(
            model='gemini-2.5-flash',
            name='Legal_Orchestrator',
            instruction=self.root_instruction,
            tools=[
                self.delegate_to_client_communication,
                self.delegate_to_legal_researcher,
                self.delegate_to_records_wrangler,
                self.delegate_to_voice_scheduler,
                self.delegate_to_evidence_sorter,
            ],
        )

    async def delegate_to_client_communication(self, task: str, tool_context: ToolContext):
        # Send task to Client Communication Agent via A2A
        pass
```

#### **Step 3: Update Backend API**

- Replace monolithic `orchestrator` function with host agent
- Add endpoints for A2A communication
- Maintain existing REST API for frontend compatibility
- Add streaming support for real-time updates

#### **Step 4: Update Frontend**

- Add support for streaming responses (SSE)
- Display task status updates in real-time
- Show which agent is handling the task
- Display artifacts as they're generated

---

## 6. Benefits of A2A Implementation

### 6.1 Scalability

- Each agent can be deployed independently
- Agents can be scaled horizontally
- New agents can be added without modifying existing ones

### 6.2 Maintainability

- Clear separation of concerns
- Each agent has a single responsibility
- Easier to test and debug

### 6.3 Flexibility

- Agents can be built with different frameworks
- Easy to swap out or upgrade individual agents
- Support for third-party agents

### 6.4 Enterprise-Ready

- Standardized authentication and authorization
- Built-in observability and tracing
- Support for long-running tasks

### 6.5 User Experience

- Real-time updates via streaming
- Transparent multi-agent collaboration
- Better error handling and recovery

---

## 7. Migration Strategy

### Phase 1: Proof of Concept (1-2 weeks)

1. Create one specialist agent (e.g., Client Communication) as A2A server
2. Create simple host agent that can delegate to it
3. Test A2A communication end-to-end

### Phase 2: Core Agents (2-3 weeks)

1. Implement remaining specialist agents
2. Enhance host agent with full routing logic
3. Integrate with existing backend services

### Phase 3: Frontend Integration (1-2 weeks)

1. Update frontend to support streaming
2. Add real-time task status updates
3. Improve UX with agent visibility

### Phase 4: Production Hardening (1-2 weeks)

1. Add authentication and authorization
2. Implement proper error handling
3. Add monitoring and observability
4. Performance optimization

---

## 8. Key Takeaways

1. **A2A is the right protocol** for our multi-agent legal AI system
2. **Each specialist should be an A2A server** with its own Agent Card
3. **The orchestrator should use ADK** with tools that call remote agents
4. **Task lifecycle management is critical** for tracking long-running operations
5. **Streaming provides better UX** for real-time updates
6. **Agent Cards enable discovery** and dynamic agent composition
7. **Opaque execution preserves IP** and enhances security
8. **The Airbnb sample is an excellent reference** for implementation patterns

---

## 9. Next Steps

1. **Review this analysis** with the team
2. **Decide on migration approach**: Big bang vs incremental
3. **Set up development environment** for A2A agents
4. **Start with POC** for one agent
5. **Iterate and expand** to full multi-agent system

---

## 10. Resources

- **A2A Protocol Docs**: https://a2a-protocol.org
- **A2A Python SDK**: https://github.com/a2aproject/a2a-python
- **ADK Docs**: https://google.github.io/adk-docs
- **Airbnb Sample**: `/Users/mac/Downloads/a2a-samples-main/samples/python/agents/airbnb_planner_multiagent`
- **A2A Spec**: `/Users/mac/Downloads/A2A-main/docs/specification.md`
